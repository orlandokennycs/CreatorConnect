{"ast":null,"code":"'use strict';\n\nconst MongoError = require('./core/error').MongoError;\n\nconst ReadPreference = require('./core/topologies/read_preference');\n\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function (obj) {\n  var copy = {};\n\n  for (var name in obj) copy[name] = obj[name];\n\n  return copy;\n}; // Figure out the read preference\n\n\nvar translateReadPreference = function (options) {\n  var r = null;\n\n  if (options.readPreference) {\n    r = options.readPreference;\n  } else {\n    return options;\n  }\n\n  if (typeof r === 'string') {\n    options.readPreference = new ReadPreference(r);\n  } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {\n    const mode = r.mode || r.preference;\n\n    if (mode && typeof mode === 'string') {\n      options.readPreference = new ReadPreference(mode, r.tags, {\n        maxStalenessSeconds: r.maxStalenessSeconds\n      });\n    }\n  } else if (!(r instanceof ReadPreference)) {\n    throw new TypeError('Invalid read preference: ' + r);\n  }\n\n  return options;\n}; // Set simple property\n\n\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\n\n\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  }); // Get all object keys\n\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {// continue\n    }\n  }\n\n  return e;\n};\n/**\n * @ignore\n */\n\n\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\n\n\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n};\n\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\n\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}; // Merge options with translation\n\n\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  } // Filtered options\n\n\n  return filterOptions;\n}; // Write concern keys\n\n\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync']; // Merge the write concern options\n\nvar mergeOptionsAndWriteConcern = function (targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  } // No merging of write concern\n\n\n  if (!mergeWriteConcern) return targetOptions; // Found no write Concern options\n\n  var found = false;\n\n  for (i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\n\n\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, opOptions, owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner && !options.returnsCursor) {\n      session.endSession(() => {\n        delete opOptions.session;\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  }; // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\n\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\n\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n/**\n * Resolves a read preference based on well-defined inheritance rules. This method will not only\n * determine the read preference (if there is one), but will also ensure the returned value is a\n * properly constructed instance of `ReadPreference`.\n *\n * @param {Collection|Db|MongoClient} parent The parent of the operation on which to determine the read\n * preference, used for determining the inherited read preference.\n * @param {Object} options The options passed into the method, potentially containing a read preference\n * @returns {(ReadPreference|null)} The resolved read preference\n */\n\n\nfunction resolveReadPreference(parent, options) {\n  options = options || {};\n  const session = options.session;\n  const inheritedReadPreference = parent.readPreference;\n  let readPreference;\n\n  if (options.readPreference) {\n    readPreference = ReadPreference.fromOptions(options);\n  } else if (session && session.inTransaction() && session.transaction.options.readPreference) {\n    // The transaction’s read preference MUST override all other user configurable read preferences.\n    readPreference = session.transaction.options.readPreference;\n  } else if (inheritedReadPreference != null) {\n    readPreference = inheritedReadPreference;\n  } else {\n    throw new Error('No readPreference was provided or inherited.');\n  }\n\n  return typeof readPreference === 'string' ? new ReadPreference(readPreference) : readPreference;\n}\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\n\n\nfunction decorateWithCollation(command, target, options) {\n  const topology = target.s && target.s.topology || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(\"Current topology does not support collation\");\n    }\n  }\n}\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\n\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  let readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nconst emitProcessWarning = msg => process.emitWarning(msg, 'DeprecationWarning');\n\nconst emitConsoleWarning = msg => console.error(msg);\n\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\n\nfunction defaultMsgHandler(name, option) {\n  return \"\".concat(name, \" option [\").concat(option, \"] is deprecated and will be removed in a later version.\");\n}\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\n\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    const options = arguments[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (options.hasOwnProperty(deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n    return fn.apply(this, arguments);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {}; // Test asyncIterator support\n\ntry {\n  require('./async/async_iterator');\n\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? \"\".concat(this.db, \".\").concat(this.collection) : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(\"Cannot parse namespace from \\\"\".concat(namespace, \"\\\"\"));\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  mergeOptionsAndWriteConcern,\n  translateReadPreference,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  resolveReadPreference,\n  emitDeprecationWarning\n};","map":null,"metadata":{},"sourceType":"script"}