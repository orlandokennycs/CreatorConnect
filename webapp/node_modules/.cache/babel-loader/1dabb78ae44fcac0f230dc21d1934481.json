{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst TopologyType = require('./common').TopologyType;\n\nconst ReadPreference = require('../topologies/read_preference');\n\nconst MongoError = require('../error').MongoError;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\n\nconst common = require('./common');\n\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom; // max staleness constants\n\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n/**\n * Returns a server selector that selects for writable servers\n */\n\nfunction writableServerSelector() {\n  return function (topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n  };\n}\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\n\n\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(\"maxStalenessSeconds must be at least \".concat(maxStalenessVariance, \" seconds\"));\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(\"maxStalenessSeconds must be at least \".concat(SMALLEST_MAX_STALENESS_SECONDS, \" seconds\"));\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = servers.filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  } else if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\n\n\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\n\n\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\n\n\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n} // filters\n\n\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\n\n\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function (topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new MongoError(\"Minimum wire version '\".concat(readPreference.minWireVersion, \"' required, but found '\").concat(commonWireVersion, \"'\"));\n    }\n\n    if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    if (readPreference.mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (readPreference.mode === ReadPreference.SECONDARY) {\n      return latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(secondaryFilter);\n    } else if (readPreference.mode === ReadPreference.NEAREST) {\n      return latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(nearestFilter);\n    } else if (readPreference.mode === ReadPreference.SECONDARY_PREFERRED) {\n      const result = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(secondaryFilter);\n      return result.length === 0 ? servers.filter(primaryFilter) : result;\n    } else if (readPreference.mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n\n      if (result.length) {\n        return result;\n      }\n\n      return latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(secondaryFilter);\n    }\n  };\n}\n/**\n * Selects servers using the provided selector\n *\n * @private\n * @param {Topology} topology The topology to select servers from\n * @param {function} selector The predicate used for selecting servers\n * @param {Number} timeout The max time we are willing wait for selection\n * @param {Number} start A high precision timestamp for the start of the selection process\n * @param {function} callback The callback used to convey errors or the resultant servers\n */\n\n\nfunction selectServers(topology, selector, timeout, start, callback) {\n  const duration = calculateDurationInMs(start);\n\n  if (duration >= timeout) {\n    return callback(new MongoTimeoutError(\"Server selection timed out after \".concat(timeout, \" ms\")), topology.description.error);\n  } // explicitly disallow selection if client is closed\n\n\n  if (topology.s.state === STATE_CLOSED) {\n    callback(new MongoError('Topology is closed, please connect'));\n    return;\n  } // otherwise, attempt server selection\n\n\n  const serverDescriptions = Array.from(topology.description.servers.values());\n  let descriptions; // support server selection by options with readPreference\n\n  if (typeof selector === 'object') {\n    const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;\n    selector = readPreferenceServerSelector(readPreference);\n  }\n\n  try {\n    descriptions = selector ? selector(topology.description, serverDescriptions) : serverDescriptions;\n  } catch (e) {\n    return callback(e, null);\n  }\n\n  if (descriptions.length) {\n    const servers = descriptions.map(description => topology.s.servers.get(description.address));\n    return callback(null, servers);\n  }\n\n  const retrySelection = () => {\n    // ensure all server monitors attempt monitoring soon\n    topology.s.servers.forEach(server => server.monitor({\n      heartbeatFrequencyMS: topology.description.heartbeatFrequencyMS\n    }));\n    const iterationTimer = setTimeout(() => {\n      topology.removeListener('topologyDescriptionChanged', descriptionChangedHandler);\n      callback(new MongoTimeoutError(\"Server selection timed out after \".concat(timeout, \" ms\"), topology.description.error));\n    }, timeout - duration);\n\n    const descriptionChangedHandler = () => {\n      // successful iteration, clear the check timer\n      clearAndRemoveTimerFrom(iterationTimer, topology.s.iterationTimers); // topology description has changed due to monitoring, reattempt server selection\n\n      selectServers(topology, selector, timeout, start, callback);\n    }; // track this timer in case we need to clean it up outside this loop\n\n\n    topology.s.iterationTimers.add(iterationTimer);\n    topology.once('topologyDescriptionChanged', descriptionChangedHandler);\n  };\n\n  retrySelection();\n}\n\nmodule.exports = {\n  selectServers,\n  writableServerSelector,\n  readPreferenceServerSelector\n};","map":null,"metadata":{},"sourceType":"script"}