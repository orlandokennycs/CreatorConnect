{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst MongoError = require('../error').MongoError;\n\nconst Pool = require('../connection/pool');\n\nconst relayEvents = require('../utils').relayEvents;\n\nconst wireProtocol = require('../wireprotocol');\n\nconst BSON = require('../connection/utils').retrieveBSON();\n\nconst createClientInfo = require('../topologies/shared').createClientInfo;\n\nconst Logger = require('../connection/logger');\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst ReadPreference = require('../topologies/read_preference');\n\nconst monitorServer = require('./monitoring').monitorServer;\n\nconst MongoParseError = require('../error').MongoParseError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst collationNotSupported = require('../utils').collationNotSupported;\n\nconst debugOptions = require('../connection/utils').debugOptions;\n\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst common = require('./common'); // Used for filtering out fields for logging\n\n\nconst DEBUG_FIELDS = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername'];\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\n\nclass Server extends EventEmitter {\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  constructor(description, options, topology) {\n    super();\n    this.s = {\n      // the server description\n      description,\n      // a saved copy of the incoming options\n      options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n      // client metadata for the initial handshake\n      clientInfo: createClientInfo(options),\n      // state variable to determine if there is an active server check in progress\n      monitoring: false,\n      // the implementation of the monitoring method\n      monitorFunction: options.monitorFunction || monitorServer,\n      // the connection pool\n      pool: null,\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology\n    };\n  }\n\n  get description() {\n    return this.s.description;\n  }\n\n  get name() {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n\n    return null;\n  }\n  /**\n   * Initiate server connect\n   */\n\n\n  connect(options) {\n    options = options || {}; // do not allow connect to be called on anything that's not disconnected\n\n    if (this.s.pool && !this.s.pool.isDisconnected() && !this.s.pool.isDestroyed()) {\n      throw new MongoError(\"Server instance in invalid state \".concat(this.s.pool.state));\n    } // create a pool\n\n\n    const addressParts = this.description.address.split(':');\n    const poolOptions = Object.assign({\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10)\n    }, this.s.options, options, {\n      bson: this.s.bson\n    }); // NOTE: reconnect is explicitly false because of the server selection loop\n\n    poolOptions.reconnect = false;\n    poolOptions.legacyCompatMode = false;\n    this.s.pool = new Pool(this, poolOptions); // setup listeners\n\n    this.s.pool.on('parseError', parseErrorEventHandler(this));\n    this.s.pool.on('drain', err => {\n      this.emit('error', err);\n    }); // it is unclear whether consumers should even know about these events\n    // this.s.pool.on('timeout', timeoutEventHandler(this));\n    // this.s.pool.on('reconnect', reconnectEventHandler(this));\n    // this.s.pool.on('reconnectFailed', errorEventHandler(this));\n    // relay all command monitoring events\n\n    relayEvents(this.s.pool, this, ['commandStarted', 'commandSucceeded', 'commandFailed']);\n    stateTransition(this, STATE_CONNECTING);\n    this.s.pool.connect(connectEventHandler(this));\n  }\n  /**\n   * Destroy the server connection\n   *\n   * @param {Boolean} [options.force=false] Force destroy the pool\n   */\n\n\n  destroy(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = Object.assign({}, {\n      force: false\n    }, options);\n\n    if (this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n\n    const done = err => {\n      stateTransition(this, STATE_CLOSED);\n      this.emit('closed');\n\n      if (typeof callback === 'function') {\n        callback(err, null);\n      }\n    };\n\n    if (!this.s.pool) {\n      return done();\n    }\n\n    ['close', 'error', 'timeout', 'parseError', 'connect'].forEach(event => {\n      this.s.pool.removeAllListeners(event);\n    });\n\n    if (this.s.monitorId) {\n      clearTimeout(this.s.monitorId);\n    }\n\n    this.s.pool.destroy(options.force, done);\n  }\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n\n\n  monitor(options) {\n    options = options || {};\n    if (this.s.state !== STATE_CONNECTED || this.s.monitoring) return;\n    if (this.s.monitorId) clearTimeout(this.s.monitorId);\n    this.s.monitorFunction(this, options);\n  }\n  /**\n   * Execute a command\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      callback = options, options = {}, options = options || {};\n    }\n\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    const error = basicReadValidations(this, options);\n\n    if (error) {\n      return callback(error, null);\n    } // Clone the options\n\n\n    options = Object.assign({}, options, {\n      wireProtocolCommand: false\n    }); // Debug log\n\n    if (this.s.logger.isDebug()) {\n      this.s.logger.debug(\"executing command [\".concat(JSON.stringify({\n        ns,\n        cmd,\n        options: debugOptions(DEBUG_FIELDS, options)\n      }), \"] against \").concat(this.name));\n    } // error if collation not supported\n\n\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoError(\"server \".concat(this.name, \" does not support collation\")));\n      return;\n    }\n\n    wireProtocol.command(this, ns, cmd, options, (err, result) => {\n      if (err) {\n        if (options.session && err instanceof MongoNetworkError) {\n          options.session.serverSession.isDirty = true;\n        }\n\n        if (isSDAMUnrecoverableError(err, this)) {\n          this.emit('error', err);\n        }\n      }\n\n      callback(err, result);\n    });\n  }\n  /**\n   * Execute a query against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command document for the query\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n\n\n  query(ns, cmd, cursorState, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    wireProtocol.query(this, ns, cmd, cursorState, options, (err, result) => {\n      if (err) {\n        if (options.session && err instanceof MongoNetworkError) {\n          options.session.serverSession.isDirty = true;\n        }\n\n        if (isSDAMUnrecoverableError(err, this)) {\n          this.emit('error', err);\n        }\n      }\n\n      callback(err, result);\n    });\n  }\n  /**\n   * Execute a `getMore` against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    wireProtocol.getMore(this, ns, cursorState, batchSize, options, (err, result) => {\n      if (err) {\n        if (options.session && err instanceof MongoNetworkError) {\n          options.session.serverSession.isDirty = true;\n        }\n\n        if (isSDAMUnrecoverableError(err, this)) {\n          this.emit('error', err);\n        }\n      }\n\n      callback(err, result);\n    });\n  }\n  /**\n   * Execute a `killCursors` command against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {function} callback\n   */\n\n\n  killCursors(ns, cursorState, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('server is closed'));\n      }\n\n      return;\n    }\n\n    wireProtocol.killCursors(this, ns, cursorState, (err, result) => {\n      if (err && isSDAMUnrecoverableError(err, this)) {\n        this.emit('error', err);\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, result);\n      }\n    });\n  }\n  /**\n   * Insert one or more documents\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of documents to insert\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'insert',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\n   * Perform one or more update operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  update(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'update',\n      ns,\n      ops\n    }, options, callback);\n  }\n  /**\n   * Perform one or more remove operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session=null] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n\n\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({\n      server: this,\n      op: 'remove',\n      ns,\n      ops\n    }, options, callback);\n  }\n\n}\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function () {\n    return this.s.topology.clusterTime;\n  },\n  set: function (clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction basicWriteValidations(server) {\n  if (!server.s.pool) {\n    return new MongoError('server instance is not connected');\n  }\n\n  if (server.s.pool.isDestroyed()) {\n    return new MongoError('server instance pool was destroyed');\n  }\n\n  return null;\n}\n\nfunction basicReadValidations(server, options) {\n  const error = basicWriteValidations(server, options);\n\n  if (error) {\n    return error;\n  }\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  const server = args.server;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n\n  const error = basicWriteValidations(server, options);\n\n  if (error) {\n    callback(error, null);\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(\"server \".concat(server.name, \" does not support collation\")));\n    return;\n  }\n\n  return wireProtocol[op](server, ns, ops, options, (err, result) => {\n    if (err) {\n      if (options.session && err instanceof MongoNetworkError) {\n        options.session.serverSession.isDirty = true;\n      }\n\n      if (isSDAMUnrecoverableError(err, server)) {\n        server.emit('error', err);\n      }\n    }\n\n    callback(err, result);\n  });\n}\n\nfunction connectEventHandler(server) {\n  return function (err, conn) {\n    if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n      return;\n    }\n\n    if (err) {\n      server.emit('error', new MongoNetworkError(err));\n      stateTransition(server, STATE_CLOSED);\n      server.emit('close');\n      return;\n    }\n\n    const ismaster = conn.ismaster;\n    server.s.lastIsMasterMS = conn.lastIsMasterMS;\n\n    if (conn.agreedCompressor) {\n      server.s.pool.options.agreedCompressor = conn.agreedCompressor;\n    }\n\n    if (conn.zlibCompressionLevel) {\n      server.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;\n    }\n\n    if (conn.ismaster.$clusterTime) {\n      const $clusterTime = conn.ismaster.$clusterTime;\n      server.s.sclusterTime = $clusterTime;\n    } // log the connection event if requested\n\n\n    if (server.s.logger.isInfo()) {\n      server.s.logger.info(\"server \".concat(server.name, \" connected with ismaster [\").concat(JSON.stringify(ismaster), \"]\"));\n    } // we are connected and handshaked (guaranteed by the pool)\n\n\n    stateTransition(server, STATE_CONNECTED);\n    server.emit('connect', server); // emit an event indicating that our description has changed\n\n    server.emit('descriptionReceived', new ServerDescription(server.description.address, ismaster));\n  };\n}\n\nfunction parseErrorEventHandler(server) {\n  return function (err) {\n    stateTransition(this, STATE_CLOSED);\n    server.emit('error', new MongoParseError(err));\n  };\n}\n\nmodule.exports = {\n  Server\n};","map":null,"metadata":{},"sourceType":"script"}