{"ast":null,"code":"'use strict';\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs; // pulled from `Server` implementation\n\n\nconst STATE_CLOSED = 'closed';\nconst STATE_CLOSING = 'closing';\n/**\n * Published when server description changes, but does NOT include changes to the RTT.\n *\n * @property {Object} topologyId A unique identifier for the topology\n * @property {ServerAddress} address The address (host/port pair) of the server\n * @property {ServerDescription} previousDescription The previous server description\n * @property {ServerDescription} newDescription The new server description\n */\n\nclass ServerDescriptionChangedEvent {\n  constructor(topologyId, address, previousDescription, newDescription) {\n    Object.assign(this, {\n      topologyId,\n      address,\n      previousDescription,\n      newDescription\n    });\n  }\n\n}\n/**\n * Published when server is initialized.\n *\n * @property {Object} topologyId A unique identifier for the topology\n * @property {ServerAddress} address The address (host/port pair) of the server\n */\n\n\nclass ServerOpeningEvent {\n  constructor(topologyId, address) {\n    Object.assign(this, {\n      topologyId,\n      address\n    });\n  }\n\n}\n/**\n * Published when server is closed.\n *\n * @property {ServerAddress} address The address (host/port pair) of the server\n * @property {Object} topologyId A unique identifier for the topology\n */\n\n\nclass ServerClosedEvent {\n  constructor(topologyId, address) {\n    Object.assign(this, {\n      topologyId,\n      address\n    });\n  }\n\n}\n/**\n * Published when topology description changes.\n *\n * @property {Object} topologyId\n * @property {TopologyDescription} previousDescription The old topology description\n * @property {TopologyDescription} newDescription The new topology description\n */\n\n\nclass TopologyDescriptionChangedEvent {\n  constructor(topologyId, previousDescription, newDescription) {\n    Object.assign(this, {\n      topologyId,\n      previousDescription,\n      newDescription\n    });\n  }\n\n}\n/**\n * Published when topology is initialized.\n *\n * @param {Object} topologyId A unique identifier for the topology\n */\n\n\nclass TopologyOpeningEvent {\n  constructor(topologyId) {\n    Object.assign(this, {\n      topologyId\n    });\n  }\n\n}\n/**\n * Published when topology is closed.\n *\n * @param {Object} topologyId A unique identifier for the topology\n */\n\n\nclass TopologyClosedEvent {\n  constructor(topologyId) {\n    Object.assign(this, {\n      topologyId\n    });\n  }\n\n}\n/**\n * Fired when the server monitor’s ismaster command is started - immediately before\n * the ismaster command is serialized into raw BSON and written to the socket.\n *\n * @property {Object} connectionId The connection id for the command\n */\n\n\nclass ServerHeartbeatStartedEvent {\n  constructor(connectionId) {\n    Object.assign(this, {\n      connectionId\n    });\n  }\n\n}\n/**\n * Fired when the server monitor’s ismaster succeeds.\n *\n * @param {Number} duration The execution time of the event in ms\n * @param {Object} reply The command reply\n * @param {Object} connectionId The connection id for the command\n */\n\n\nclass ServerHeartbeatSucceededEvent {\n  constructor(duration, reply, connectionId) {\n    Object.assign(this, {\n      duration,\n      reply,\n      connectionId\n    });\n  }\n\n}\n/**\n * Fired when the server monitor’s ismaster fails, either with an “ok: 0” or a socket exception.\n *\n * @param {Number} duration The execution time of the event in ms\n * @param {MongoError|Object} failure The command failure\n * @param {Object} connectionId The connection id for the command\n */\n\n\nclass ServerHeartbeatFailedEvent {\n  constructor(duration, failure, connectionId) {\n    Object.assign(this, {\n      duration,\n      failure,\n      connectionId\n    });\n  }\n\n}\n/**\n * Performs a server check as described by the SDAM spec.\n *\n * NOTE: This method automatically reschedules itself, so that there is always an active\n * monitoring process\n *\n * @param {Server} server The server to monitor\n */\n\n\nfunction monitorServer(server, options) {\n  options = options || {};\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n\n  if (options.initial === true) {\n    server.s.monitorId = setTimeout(() => monitorServer(server), heartbeatFrequencyMS);\n    return;\n  }\n\n  const rescheduleMonitoring = () => {\n    server.s.monitoring = false;\n    server.s.monitorId = setTimeout(() => {\n      server.s.monitorId = undefined;\n      server.monitor();\n    }, heartbeatFrequencyMS);\n  }; // executes a single check of a server\n\n\n  const checkServer = callback => {\n    let start = process.hrtime(); // emit a signal indicating we have started the heartbeat\n\n    server.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(server.name)); // NOTE: legacy monitoring event\n\n    process.nextTick(() => server.emit('monitoring', server));\n    server.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true,\n      socketTimeout: server.s.options.connectionTimeout || 2000\n    }, (err, result) => {\n      let duration = calculateDurationInMs(start);\n\n      if (err) {\n        server.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(duration, err, server.name));\n        return callback(err, null);\n      } // save round trip time\n\n\n      server.description.roundTripTime = duration;\n      const isMaster = result.result;\n      server.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(duration, isMaster, server.name));\n      return callback(null, isMaster);\n    });\n  };\n\n  const successHandler = isMaster => {\n    // emit an event indicating that our description has changed\n    server.emit('descriptionReceived', new ServerDescription(server.description.address, isMaster));\n\n    if (server.s.state === STATE_CLOSED || server.s.state === STATE_CLOSING) {\n      return;\n    }\n\n    rescheduleMonitoring();\n  }; // run the actual monitoring loop\n\n\n  server.s.monitoring = true;\n  checkServer((err, isMaster) => {\n    if (!err) {\n      successHandler(isMaster);\n      return;\n    } // According to the SDAM specification's \"Network error during server check\" section, if\n    // an ismaster call fails we reset the server's pool. If a server was once connected,\n    // change its type to `Unknown` only after retrying once.\n\n\n    server.s.pool.reset(() => {\n      // otherwise re-attempt monitoring once\n      checkServer((error, isMaster) => {\n        if (error) {\n          // we revert to an `Unknown` by emitting a default description with no isMaster\n          server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {\n            error\n          }));\n          rescheduleMonitoring();\n          return;\n        }\n\n        successHandler(isMaster);\n      });\n    });\n  });\n}\n\nmodule.exports = {\n  ServerDescriptionChangedEvent,\n  ServerOpeningEvent,\n  ServerClosedEvent,\n  TopologyDescriptionChangedEvent,\n  TopologyOpeningEvent,\n  TopologyClosedEvent,\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent,\n  ServerHeartbeatFailedEvent,\n  monitorServer\n};","map":null,"metadata":{},"sourceType":"script"}