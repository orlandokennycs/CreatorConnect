{"ast":null,"code":"'use strict';\n\nconst Aspect = require('./operation').Aspect;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nclass CreateIndexesOperation extends OperationBase {\n  constructor(collection, indexSpecs, options) {\n    super(options);\n    this.collection = collection;\n    this.indexSpecs = indexSpecs;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const indexSpecs = this.indexSpecs;\n    let options = this.options;\n    const capabilities = coll.s.topology.capabilities(); // Ensure we generate the correct name if the parameter is not set\n\n    for (let i = 0; i < indexSpecs.length; i++) {\n      if (indexSpecs[i].name == null) {\n        const keys = []; // Did the user pass in a collation, check if our write server supports it\n\n        if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n          return callback(new MongoError('server/primary/mongos does not support collation'));\n        }\n\n        for (let name in indexSpecs[i].key) {\n          keys.push(\"\".concat(name, \"_\").concat(indexSpecs[i].key[name]));\n        } // Set the name\n\n\n        indexSpecs[i].name = keys.join('_');\n      }\n    }\n\n    options = Object.assign({}, options, {\n      readPreference: ReadPreference.PRIMARY\n    }); // Execute the index\n\n    executeCommand(coll.s.db, {\n      createIndexes: coll.collectionName,\n      indexes: indexSpecs\n    }, options, callback);\n  }\n\n}\n\ndefineAspects(CreateIndexesOperation, Aspect.WRITE_OPERATION);\nmodule.exports = CreateIndexesOperation;","map":null,"metadata":{},"sourceType":"script"}