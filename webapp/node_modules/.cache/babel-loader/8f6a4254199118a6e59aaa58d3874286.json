{"ast":null,"code":"'use strict';\n\nconst Aspect = require('./operation').Aspect;\n\nconst defineAspects = require('./operation').defineAspects;\n\nconst CommandOperation = require('./command');\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst loadCollection = require('../dynamic_loaders').loadCollection;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference; // Filter out any write concern options\n\n\nconst illegalCommandFields = ['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'strict', 'serializeFunctions', 'pkFactory', 'raw', 'readPreference', 'session', 'readConcern', 'writeConcern'];\n\nclass CreateCollectionOperation extends CommandOperation {\n  constructor(db, name, options) {\n    super(db, options);\n    this.name = name;\n  }\n\n  _buildCommand() {\n    const name = this.name;\n    const options = this.options; // Create collection command\n\n    const cmd = {\n      create: name\n    }; // Add all optional parameters\n\n    for (let n in options) {\n      if (options[n] != null && typeof options[n] !== 'function' && illegalCommandFields.indexOf(n) === -1) {\n        cmd[n] = options[n];\n      }\n    }\n\n    return cmd;\n  }\n\n  execute(callback) {\n    const db = this.db;\n    const name = this.name;\n    const options = this.options;\n    let Collection = loadCollection(); // Did the user destroy the topology\n\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    let listCollectionOptions = Object.assign({}, options, {\n      nameOnly: true\n    });\n    listCollectionOptions = applyWriteConcern(listCollectionOptions, {\n      db\n    }, listCollectionOptions); // Check if we have the name\n\n    db.listCollections({\n      name\n    }, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {\n      if (err != null) return handleCallback(callback, err, null);\n\n      if (collections.length > 0 && listCollectionOptions.strict) {\n        return handleCallback(callback, MongoError.create({\n          message: \"Collection \".concat(name, \" already exists. Currently in strict mode.\"),\n          driver: true\n        }), null);\n      } else if (collections.length > 0) {\n        try {\n          return handleCallback(callback, null, new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options));\n        } catch (err) {\n          return handleCallback(callback, err);\n        }\n      } // Execute command\n\n\n      super.execute(err => {\n        if (err) return handleCallback(callback, err);\n\n        try {\n          return handleCallback(callback, null, new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options));\n        } catch (err) {\n          return handleCallback(callback, err);\n        }\n      });\n    });\n  }\n\n}\n\ndefineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);\nmodule.exports = CreateCollectionOperation;","map":null,"metadata":{},"sourceType":"script"}