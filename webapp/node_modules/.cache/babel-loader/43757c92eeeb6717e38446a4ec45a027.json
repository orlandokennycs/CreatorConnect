{"ast":null,"code":"'use strict';\n\nconst MongoError = require('../error').MongoError;\n/**\n * Creates a new AuthProvider, which dictates how to authenticate for a given\n * mechanism.\n * @class\n */\n\n\nclass AuthProvider {\n  constructor(bson) {\n    this.bson = bson;\n    this.authStore = [];\n  }\n  /**\n   * Authenticate\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {MongoCredentials} credentials Authentication credentials\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n\n\n  auth(sendAuthCommand, connections, credentials, callback) {\n    // Total connections\n    let count = connections.length;\n\n    if (count === 0) {\n      callback(null, null);\n      return;\n    } // Valid connections\n\n\n    let numberOfValidConnections = 0;\n    let errorObject = null;\n\n    const execute = connection => {\n      this._authenticateSingleConnection(sendAuthCommand, connection, credentials, (err, r) => {\n        // Adjust count\n        count = count - 1; // If we have an error\n\n        if (err) {\n          errorObject = new MongoError(err);\n        } else if (r && (r.$err || r.errmsg)) {\n          errorObject = new MongoError(r);\n        } else {\n          numberOfValidConnections = numberOfValidConnections + 1;\n        } // Still authenticating against other connections.\n\n\n        if (count !== 0) {\n          return;\n        } // We have authenticated all connections\n\n\n        if (numberOfValidConnections > 0) {\n          // Store the auth details\n          this.addCredentials(credentials); // Return correct authentication\n\n          callback(null, true);\n        } else {\n          if (errorObject == null) {\n            errorObject = new MongoError(\"failed to authenticate using \".concat(credentials.mechanism));\n          }\n\n          callback(errorObject, false);\n        }\n      });\n    };\n\n    const executeInNextTick = _connection => process.nextTick(() => execute(_connection)); // For each connection we need to authenticate\n\n\n    while (connections.length > 0) {\n      executeInNextTick(connections.shift());\n    }\n  }\n  /**\n   * Implementation of a single connection authenticating. Is meant to be overridden.\n   * Will error if called directly\n   * @ignore\n   */\n\n\n  _authenticateSingleConnection()\n  /*sendAuthCommand, connection, credentials, callback*/\n  {\n    throw new Error('_authenticateSingleConnection must be overridden');\n  }\n  /**\n   * Adds credentials to store only if it does not exist\n   * @param {MongoCredentials} credentials credentials to add to store\n   */\n\n\n  addCredentials(credentials) {\n    const found = this.authStore.some(cred => cred.equals(credentials));\n\n    if (!found) {\n      this.authStore.push(credentials);\n    }\n  }\n  /**\n   * Re authenticate pool\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n\n\n  reauthenticate(sendAuthCommand, connections, callback) {\n    const authStore = this.authStore.slice(0);\n    let count = authStore.length;\n\n    if (count === 0) {\n      return callback(null, null);\n    }\n\n    for (let i = 0; i < authStore.length; i++) {\n      this.auth(sendAuthCommand, connections, authStore[i], function (err) {\n        count = count - 1;\n\n        if (count === 0) {\n          callback(err, null);\n        }\n      });\n    }\n  }\n  /**\n   * Remove credentials that have been previously stored in the auth provider\n   * @method\n   * @param {string} source Name of database we are removing authStore details about\n   * @return {object}\n   */\n\n\n  logout(source) {\n    this.authStore = this.authStore.filter(credentials => credentials.source !== source);\n  }\n\n}\n/**\n * A function that writes authentication commands to a specific connection\n * @callback SendAuthCommand\n * @param {Connection} connection The connection to write to\n * @param {Command} command A command with a toBin method that can be written to a connection\n * @param {AuthWriteCallback} callback Callback called when command response is received\n */\n\n/**\n * A callback for a specific auth command\n * @callback AuthWriteCallback\n * @param {Error} err If command failed, an error from the server\n * @param {object} r The response from the server\n */\n\n/**\n * This is a result from an authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\n\nmodule.exports = {\n  AuthProvider\n};","map":null,"metadata":{},"sourceType":"script"}